import sys

from datetime import datetime

from parse_types import Structure, Enumeration


class VisitorGenerator:
    indent_size = 4

    def __init__(self, output_file=None, namespace="generated"):
        self._output_file = output_file
        self._namespace = namespace
        self.indent_level = 0
        self._output_file_handle = None

    def __enter__(self):
        self._open_file()
        self._generate_preamble()
        return self

    def _open_file(self):
        self._output_file_handle = open(self._output_file, "w") if self._output_file is not None else sys.stdout

    def _close_file(self):
        if self._output_file_handle is not sys.stdout:
            self._output_file_handle.close()

    def __exit__(self, exc_type, exc_value, exc_traceback):
        self._generate_postamble()
        self._close_file()

    def _output(self, text: str):
        """Outputs input text with a newline at current indent level"""
        indent = " " * self.indent_size * self.indent_level
        print(f"{indent}{text}", file=self._output_file_handle)

    def _generate_preamble(self):
        self._output("#pragma once\n")
        self._output(f"// Autogenerated at {datetime.now()} by {__file__}.")
        self._output("// Do not edit, changes will be overwritten!\n")
        self._output("#include <type_traits>")
        self._output("")
        self._output(f"namespace {self._namespace} {{")
        self._output("")

    def _generate_postamble(self):
        self._output(f"}} // namespace {self._namespace}")

    def generate_struct_visitors(self, structures):
        for s in structures:
            self._generate_struct_visitor(s, structures)

    def _generate_struct_visitor(self, s, structures):
        # instance visitor
        # Use SFINAE template to generate const and non-const ref "overloads"
        self._output(
            f"template <typename VisitorType, typename T, std::enable_if_t<std::is_same_v<{s.typename}, std::remove_const_t<T>>, bool> = true>"
        )
        self._output(f"constexpr void visit([[maybe_unused]] T& toVisit, [[maybe_unused]] Visitor&& visitor) {{")
        with IndentBlock(self):
            for base in s.base_classes:
                # don't force the base class to have been annotated for visitation
                # TODO: hash table
                for p in structures:
                    if p.typename == base:
                        self._output(f"visit(static_cast<{base}&>(toVisit), visitor);")
                        break
                else:
                    self._output(f"// not visiting unannotated base class {base}")
            for field_name in s.public_fields:
                self._output(f'visitor("{field_name}", toVisit.{field_name});')
        self._output("}")
        self._output("")

        # type visitor
        self._output("template <typename Visitor>")
        self._output(f"struct Acceptor<{s.typename}, Visitor> {{")
        with IndentBlock(self):
            self._output("static constexpr void visit([[maybe_unused]] Visitor&& visitor) {")
            # TODO: is this right?
            for base in s.base_classes:
                # don't force the base class to have been annotated for visitation
                # TODO: hash table
                for p in structures:
                    if p.typename == base:
                        self._output(f"visit<{base}>(visitor);")
                        break
                else:
                    self._output(f"// not visiting unannotated base class {base}")
            for field_name, field_struct in s.public_fields.items():
                self._output(f'visitor("{field_name}", type_tag<{field_struct.typename}>{{}});')
            self._output("}")
        self._output("};")
        self._output("")

    def generate_enum_visitors(self, enumerations):
        for e in enumerations:
            self._generate_enum_visitor(e)

    def _generate_enum_visitor(self, e):
        self._output("template <typename Visitor>")
        self._output(f"struct Acceptor<{e.name}, Visitor> {{")
        with IndentBlock(self):
            self._output("static constexpr void visit([[maybe_unused]] Visitor&& visitor) {")
            with IndentBlock(self):
                for p in e.enumerators:
                    # scoped names work for accessing unscoped enum elements too
                    self._output(f'visitor({e.name}::{p[0]}, "{p[0]}", std::underlying_type_t<{e.name}>{{{p[1]}}});')
            self._output("}")
        self._output("};")
        self._output("")


class IndentBlock:
    def __init__(self, generator):
        self._generator = generator

    def __enter__(self):
        self._generator.indent_level += 1
        return self

    def __exit__(self, exc_type, exc_value, exc_traceback):
        self._generator.indent_level -= 1
