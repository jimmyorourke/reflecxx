#pragma once

// Autogenerated at 2021-05-25 22:36:43.075382 by C:\Users\Jim\Desktop\wip\parse.py
// Do not edit, changes will be overwritten!

#include <type_traits>

namespace generated {

template <typename VisitorType, typename T, std::enable_if_t<std::is_same_v<Empty, std::remove_const_t<T>>, bool> = true>
constexpr void visit([[maybe_unused]] T& toVisit, [[maybe_unused]] VisitorType&& visitor) {
}

template <typename VisitorType, typename T, std::enable_if_t<std::is_same_v<Basics, std::remove_const_t<T>>, bool> = true>
constexpr void visit([[maybe_unused]] T& toVisit, [[maybe_unused]] VisitorType&& visitor) {
    visitor("b", toVisit.b);
    visitor("i", toVisit.i);
    visitor("u", toVisit.u);
    visitor("d", toVisit.d);
    visitor("f", toVisit.f);
    visitor("c", toVisit.c);
}

template <typename VisitorType, typename T, std::enable_if_t<std::is_same_v<Containers, std::remove_const_t<T>>, bool> = true>
constexpr void visit([[maybe_unused]] T& toVisit, [[maybe_unused]] VisitorType&& visitor) {
    visitor("icarr", toVisit.icarr);
    visitor("dstdarr", toVisit.dstdarr);
    visitor("fset", toVisit.fset);
    visitor("ivec", toVisit.ivec);
    visitor("s", toVisit.s);
}

template <typename VisitorType, typename T, std::enable_if_t<std::is_same_v<Wrapper, std::remove_const_t<T>>, bool> = true>
constexpr void visit([[maybe_unused]] T& toVisit, [[maybe_unused]] VisitorType&& visitor) {
    visitor("i", toVisit.i);
    visitor("d", toVisit.d);
    visitor("b", toVisit.b);
    visitor("c", toVisit.c);
    visitor("basicsArr", toVisit.basicsArr);
    visitor("containersStdarr", toVisit.containersStdarr);
}

template <typename VisitorType, typename T, std::enable_if_t<std::is_same_v<BasicClass, std::remove_const_t<T>>, bool> = true>
constexpr void visit([[maybe_unused]] T& toVisit, [[maybe_unused]] VisitorType&& visitor) {
    visitor("b", toVisit.b);
    visitor("i", toVisit.i);
    visitor("d", toVisit.d);
}

template <typename VisitorType, typename T, std::enable_if_t<std::is_same_v<ChildClass, std::remove_const_t<T>>, bool> = true>
constexpr void visit([[maybe_unused]] T& toVisit, [[maybe_unused]] VisitorType&& visitor) {
    visit(static_cast<BasicClass&>(toVisit), visitor);
    visitor("publicField", toVisit.publicField);
}

template <typename VisitorType, typename T, std::enable_if_t<std::is_same_v<ChildOfUnreflectedBaseClass, std::remove_const_t<T>>, bool> = true>
constexpr void visit([[maybe_unused]] T& toVisit, [[maybe_unused]] VisitorType&& visitor) {
    // not visiting unannotated base class UnreflectedBaseClass
    visitor("chieldField", toVisit.chieldField);
}

template <typename Visitor>
struct Acceptor<Uscoped, Visitor> {
    static constexpr void visit(Visitor&& visitor) {
        visitor(Uscoped::First, "First", std::underlying_type_t<Uscoped>{2});
        visitor(Uscoped::Second, "Second", std::underlying_type_t<Uscoped>{3});
        visitor(Uscoped::Third, "Third", std::underlying_type_t<Uscoped>{4});
    }
};

template <typename Visitor>
struct Acceptor<Scoped, Visitor> {
    static constexpr void visit(Visitor&& visitor) {
        visitor(Scoped::First, "First", std::underlying_type_t<Scoped>{0});
        visitor(Scoped::Second, "Second", std::underlying_type_t<Scoped>{1});
        visitor(Scoped::Third, "Third", std::underlying_type_t<Scoped>{2});
    }
};

} // namespace generated
