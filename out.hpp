#pragma once

// Autogenerated at 2021-05-28 18:08:48.863997 by C:\Users\Jim\Desktop\wip\visitor_generator.py.
// Do not edit, changes will be overwritten!

#include <type_traits>

namespace proto {

template<>
struct is_proto_visitable<Empty> : std::true_type {};

template<>
struct TupleType<Empty> {
    using type = std::tuple<>;
};
template <typename Visitor, typename T, std::enable_if_t<std::is_same_v<Empty, std::remove_const_t<T>>, bool> = true>
constexpr void visit([[maybe_unused]] T& toVisit, [[maybe_unused]] Visitor&& visitor, [[maybe_unused]] bool visitBaseClasses=true) {
}

namespace detail {
template <typename Visitor>
struct Acceptor<Empty, Visitor> {
    static constexpr void visitd([[maybe_unused]] Visitor&& visitor, [[maybe_unused]] bool visitBaseClasses=true) {
    }
};
} // namespace detail

template<>
struct is_proto_visitable<Basics> : std::true_type {};

template<>
struct TupleType<Basics> {
    using type = std::tuple<bool, int, double>;
};
template <typename Visitor, typename T, std::enable_if_t<std::is_same_v<Basics, std::remove_const_t<T>>, bool> = true>
constexpr void visit([[maybe_unused]] T& toVisit, [[maybe_unused]] Visitor&& visitor, [[maybe_unused]] bool visitBaseClasses=true) {
    visitor("b", toVisit.b);
    visitor("i", toVisit.i);
    visitor("d", toVisit.d);
}

namespace detail {
template <typename Visitor>
struct Acceptor<Basics, Visitor> {
    static constexpr void visitd([[maybe_unused]] Visitor&& visitor, [[maybe_unused]] bool visitBaseClasses=true) {
    visitor("b", type_tag<bool>{});
    visitor("i", type_tag<int>{});
    visitor("d", type_tag<double>{});
    }
};
} // namespace detail

template<>
struct is_proto_visitable<Wrapper> : std::true_type {};

template<>
struct TupleType<Wrapper> {
    using type = std::tuple<int, double, Basics, Basics [3], std::array<Basics, 2>>;
};
template <typename Visitor, typename T, std::enable_if_t<std::is_same_v<Wrapper, std::remove_const_t<T>>, bool> = true>
constexpr void visit([[maybe_unused]] T& toVisit, [[maybe_unused]] Visitor&& visitor, [[maybe_unused]] bool visitBaseClasses=true) {
    visitor("i", toVisit.i);
    visitor("d", toVisit.d);
    visitor("b", toVisit.b);
    visitor("basicsArr", toVisit.basicsArr);
    visitor("basicsStdarr", toVisit.basicsStdarr);
}

namespace detail {
template <typename Visitor>
struct Acceptor<Wrapper, Visitor> {
    static constexpr void visitd([[maybe_unused]] Visitor&& visitor, [[maybe_unused]] bool visitBaseClasses=true) {
    visitor("i", type_tag<int>{});
    visitor("d", type_tag<double>{});
    visitor("b", type_tag<Basics>{});
    visitor("basicsArr", type_tag<Basics [3]>{});
    visitor("basicsStdarr", type_tag<std::array<Basics, 2>>{});
    }
};
} // namespace detail

template<>
struct is_proto_visitable<BasicClass> : std::true_type {};

template<>
struct TupleType<BasicClass> {
    using type = std::tuple<bool, int, double>;
};
template <typename Visitor, typename T, std::enable_if_t<std::is_same_v<BasicClass, std::remove_const_t<T>>, bool> = true>
constexpr void visit([[maybe_unused]] T& toVisit, [[maybe_unused]] Visitor&& visitor, [[maybe_unused]] bool visitBaseClasses=true) {
    visitor("b", toVisit.b);
    visitor("i", toVisit.i);
    visitor("d", toVisit.d);
}

namespace detail {
template <typename Visitor>
struct Acceptor<BasicClass, Visitor> {
    static constexpr void visitd([[maybe_unused]] Visitor&& visitor, [[maybe_unused]] bool visitBaseClasses=true) {
    visitor("b", type_tag<bool>{});
    visitor("i", type_tag<int>{});
    visitor("d", type_tag<double>{});
    }
};
} // namespace detail

template<>
struct is_proto_visitable<ChildClass> : std::true_type {};

template<>
struct TupleType<ChildClass> {
    using type = std::tuple<int>;
};
template <typename Visitor, typename T, std::enable_if_t<std::is_same_v<ChildClass, std::remove_const_t<T>>, bool> = true>
constexpr void visit([[maybe_unused]] T& toVisit, [[maybe_unused]] Visitor&& visitor, [[maybe_unused]] bool visitBaseClasses=true) {
    if (visitBaseClasses) {
        visit(static_cast<BasicClass&>(toVisit), visitor);
    }
    visitor("publicField", toVisit.publicField);
}

namespace detail {
template <typename Visitor>
struct Acceptor<ChildClass, Visitor> {
    static constexpr void visitd([[maybe_unused]] Visitor&& visitor, [[maybe_unused]] bool visitBaseClasses=true) {
    if (visitBaseClasses) {
        visit<BasicClass>(visitor);
    }
    visitor("publicField", type_tag<int>{});
    }
};
} // namespace detail

template<>
struct is_proto_visitable<ChildOfUnreflectedBaseClass> : std::true_type {};

template<>
struct TupleType<ChildOfUnreflectedBaseClass> {
    using type = std::tuple<int>;
};
template <typename Visitor, typename T, std::enable_if_t<std::is_same_v<ChildOfUnreflectedBaseClass, std::remove_const_t<T>>, bool> = true>
constexpr void visit([[maybe_unused]] T& toVisit, [[maybe_unused]] Visitor&& visitor, [[maybe_unused]] bool visitBaseClasses=true) {
    // not visiting unannotated base class UnreflectedBaseClass
    visitor("chieldField", toVisit.chieldField);
}

namespace detail {
template <typename Visitor>
struct Acceptor<ChildOfUnreflectedBaseClass, Visitor> {
    static constexpr void visitd([[maybe_unused]] Visitor&& visitor, [[maybe_unused]] bool visitBaseClasses=true) {
    // not visiting unannotated base class UnreflectedBaseClass
    visitor("chieldField", type_tag<int>{});
    }
};
} // namespace detail

namespace detail {
template <typename Visitor>
struct Acceptor<Unscoped, Visitor> {
    static constexpr void visitd([[maybe_unused]] Visitor&& visitor, bool) {
        visitor(Unscoped::First, "First", std::underlying_type_t<Unscoped>{2});
        visitor(Unscoped::Second, "Second", std::underlying_type_t<Unscoped>{3});
        visitor(Unscoped::Third, "Third", std::underlying_type_t<Unscoped>{4});
        visitor(Unscoped::Fourth, "Fourth", std::underlying_type_t<Unscoped>{5});
    }
};
} // namespace detail

namespace detail {
template <typename Visitor>
struct Acceptor<Scoped, Visitor> {
    static constexpr void visitd([[maybe_unused]] Visitor&& visitor, bool) {
        visitor(Scoped::First, "First", std::underlying_type_t<Scoped>{0});
        visitor(Scoped::Second, "Second", std::underlying_type_t<Scoped>{1});
        visitor(Scoped::Third, "Third", std::underlying_type_t<Scoped>{2});
    }
};
} // namespace detail

} // namespace proto
