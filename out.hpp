#pragma once

// Autogenerated at 2021-06-03 22:17:00.675699 by C:\Users\Jim\Desktop\wip\visitor_generator.py.
// Do not edit, changes will be overwritten!

#include <type_traits>

#include <proto/proto_base.hpp>

namespace proto {

template<>
struct is_proto_visitable<test_types::Empty> : std::true_type {};

template<>
struct TupleType<test_types::Empty> {
    using type = std::tuple<>;
};
template <typename Visitor, typename T, std::enable_if_t<std::is_same_v<test_types::Empty, std::remove_const_t<T>>, bool> = true>
constexpr void visit([[maybe_unused]] T& toVisit, [[maybe_unused]] Visitor&& visitor) {
}

namespace detail {
template <typename Visitor>
struct Acceptor<test_types::Empty, Visitor> {
    static constexpr void visitd([[maybe_unused]] Visitor&& visitor) {
    }
};
} // namespace detail

template<>
struct is_proto_visitable<test_types::Basics> : std::true_type {};

template<>
struct TupleType<test_types::Basics> {
    using type = std::tuple<bool, int, double>;
};
template <typename Visitor, typename T, std::enable_if_t<std::is_same_v<test_types::Basics, std::remove_const_t<T>>, bool> = true>
constexpr void visit([[maybe_unused]] T& toVisit, [[maybe_unused]] Visitor&& visitor) {
    visitor("b", toVisit.b);
    visitor("i", toVisit.i);
    visitor("d", toVisit.d);
}

namespace detail {
template <typename Visitor>
struct Acceptor<test_types::Basics, Visitor> {
    static constexpr void visitd([[maybe_unused]] Visitor&& visitor) {
    visitor("b", type_tag<bool>{});
    visitor("i", type_tag<int>{});
    visitor("d", type_tag<double>{});
    }
};
} // namespace detail

template<>
struct is_proto_visitable<test_types::Wrapper> : std::true_type {};

template<>
struct TupleType<test_types::Wrapper> {
    using type = std::tuple<int, double, test_types::Basics, test_types::Basics [3], std::array<test_types::Basics, 2>>;
};
template <typename Visitor, typename T, std::enable_if_t<std::is_same_v<test_types::Wrapper, std::remove_const_t<T>>, bool> = true>
constexpr void visit([[maybe_unused]] T& toVisit, [[maybe_unused]] Visitor&& visitor) {
    visitor("i", toVisit.i);
    visitor("d", toVisit.d);
    visitor("b", toVisit.b);
    visitor("basicsArr", toVisit.basicsArr);
    visitor("basicsStdarr", toVisit.basicsStdarr);
}

namespace detail {
template <typename Visitor>
struct Acceptor<test_types::Wrapper, Visitor> {
    static constexpr void visitd([[maybe_unused]] Visitor&& visitor) {
    visitor("i", type_tag<int>{});
    visitor("d", type_tag<double>{});
    visitor("b", type_tag<test_types::Basics>{});
    visitor("basicsArr", type_tag<test_types::Basics [3]>{});
    visitor("basicsStdarr", type_tag<std::array<test_types::Basics, 2>>{});
    }
};
} // namespace detail

template<>
struct is_proto_visitable<test_types::BasicClass> : std::true_type {};

template<>
struct TupleType<test_types::BasicClass> {
    using type = std::tuple<bool, int, double>;
};
template <typename Visitor, typename T, std::enable_if_t<std::is_same_v<test_types::BasicClass, std::remove_const_t<T>>, bool> = true>
constexpr void visit([[maybe_unused]] T& toVisit, [[maybe_unused]] Visitor&& visitor) {
    visitor("b", toVisit.b);
    visitor("i", toVisit.i);
    visitor("d", toVisit.d);
}

namespace detail {
template <typename Visitor>
struct Acceptor<test_types::BasicClass, Visitor> {
    static constexpr void visitd([[maybe_unused]] Visitor&& visitor) {
    visitor("b", type_tag<bool>{});
    visitor("i", type_tag<int>{});
    visitor("d", type_tag<double>{});
    }
};
} // namespace detail

template<>
struct is_proto_visitable<test_types::ChildClass> : std::true_type {};

template<>
struct TupleType<test_types::ChildClass> {
    using type = std::tuple<bool, int, double, int>;
};
template <typename Visitor, typename T, std::enable_if_t<std::is_same_v<test_types::ChildClass, std::remove_const_t<T>>, bool> = true>
constexpr void visit([[maybe_unused]] T& toVisit, [[maybe_unused]] Visitor&& visitor) {
    visit(static_cast<test_types::BasicClass&>(toVisit), visitor);
    visitor("publicField", toVisit.publicField);
}

namespace detail {
template <typename Visitor>
struct Acceptor<test_types::ChildClass, Visitor> {
    static constexpr void visitd([[maybe_unused]] Visitor&& visitor) {
    visit<test_types::BasicClass>(visitor);
    visitor("publicField", type_tag<int>{});
    }
};
} // namespace detail

template<>
struct is_proto_visitable<test_types::ChildOfUnreflectedBaseClass> : std::true_type {};

template<>
struct TupleType<test_types::ChildOfUnreflectedBaseClass> {
    using type = std::tuple<int>;
};
template <typename Visitor, typename T, std::enable_if_t<std::is_same_v<test_types::ChildOfUnreflectedBaseClass, std::remove_const_t<T>>, bool> = true>
constexpr void visit([[maybe_unused]] T& toVisit, [[maybe_unused]] Visitor&& visitor) {
    // not visiting unannotated base class test_types::UnreflectedBaseClass
    visitor("chieldField", toVisit.chieldField);
}

namespace detail {
template <typename Visitor>
struct Acceptor<test_types::ChildOfUnreflectedBaseClass, Visitor> {
    static constexpr void visitd([[maybe_unused]] Visitor&& visitor) {
    // not visiting unannotated base class test_types::UnreflectedBaseClass
    visitor("chieldField", type_tag<int>{});
    }
};
} // namespace detail

namespace detail {
template <typename Visitor>
struct Acceptor<test_types::Unscoped, Visitor> {
    static constexpr void visitd([[maybe_unused]] Visitor&& visitor) {
        visitor(test_types::Unscoped::First, "First", std::underlying_type_t<test_types::Unscoped>{2});
        visitor(test_types::Unscoped::Second, "Second", std::underlying_type_t<test_types::Unscoped>{3});
        visitor(test_types::Unscoped::Third, "Third", std::underlying_type_t<test_types::Unscoped>{4});
        visitor(test_types::Unscoped::Fourth, "Fourth", std::underlying_type_t<test_types::Unscoped>{5});
    }
};
} // namespace detail

namespace detail {
template <typename Visitor>
struct Acceptor<test_types::Scoped, Visitor> {
    static constexpr void visitd([[maybe_unused]] Visitor&& visitor) {
        visitor(test_types::Scoped::First, "First", std::underlying_type_t<test_types::Scoped>{0});
        visitor(test_types::Scoped::Second, "Second", std::underlying_type_t<test_types::Scoped>{1});
        visitor(test_types::Scoped::Third, "Third", std::underlying_type_t<test_types::Scoped>{2});
    }
};
} // namespace detail

} // namespace proto
