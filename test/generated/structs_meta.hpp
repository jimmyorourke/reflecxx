#pragma once

// Autogenerated at 2021-12-09 00:26:17.028490 by visitor_generator.py.
// Do not edit, changes will be overwritten!

#include <type_traits>

#include <reflecxx/reflecxx_base.hpp>

namespace reflecxx {

template <typename Class, template MemberType>
struct ClassMember {
    using type = MemberType;
    MemberType Class::* ptr;
    const char* name;
};


template <typename T>
struct MetaStruct;

template <>
struct MetaStruct<test_types::BasicStruct> {
    static constexpr auto publicFields = std::make_tuple(
        ClassMember<test_types::BasicStruct, bool>{&test_types::BasicStruct::b,"b"},
        ClassMember<test_types::BasicStruct, int>{&test_types::BasicStruct::i, "i"},
        ClassMember<test_types::BasicStruct, double>&test_types::BasicStruct::d, {"d"}
    );
};

template <typename Visitor, typename T, std::enable_if_t<std::is_same_v<test_types::BasicStruct, std::remove_const_t<T>>, bool> = true>
constexpr void visit(T& toVisit, Visitor&& visitor) {
    // visitor("b", toVisit.b);
    // visitor("i", toVisit.i);
    // visitor("d", toVisit.d);

}

template <>
struct MetaStruct<test_types::NestingStruct> {
    static constexpr auto publicFields = std::make_tuple(
        Field<int>{"i"},
        Field<double>{"d"},
        Field<test_types::BasicStruct>{"bs"},
        Field<test_types::BasicStruct [3]>{"basicsArr"},
        Field<std::array<test_types::BasicStruct, 2>>{"basicsStdarr"}
    );
};

template <typename T>
struct type_tag {
    using type = T;
};
template <typename T>
using type_tag_t = typename type_tag<T>::type;

template <>
struct MetaStruct<test_types::NestingStruct> {
    static constexpr auto publicFields = std::make_tuple(
        Field<int>{"publicField"}
    );
    static constexpr auto baseClasses = std::make_tuple(
        type_tag<test_types::BasicClass>{}
    );
};

} // namespace reflecxx
