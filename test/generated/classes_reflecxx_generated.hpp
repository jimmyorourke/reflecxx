#pragma once

// Autogenerated by visitor_generator.py.
// Do not edit, changes will be overwritten!

#include <type_traits>

#include <reflecxx/types.hpp>

namespace reflecxx::detail {

////////////////////////////////////////////////////////////
// test_types::BasicClass
////////////////////////////////////////////////////////////

template <>
struct MetaStructInternal<test_types::BasicClass> {
    using Type = test_types::BasicClass;
    static constexpr std::string_view name{"BasicClass"};
    static constexpr auto publicFields = std::make_tuple(
        ClassMember<Type, bool>{&Type::b, "b"},
        ClassMember<Type, int>{&Type::i, "i"},
        ClassMember<Type, double>{&Type::d, "d"}
    );
    static constexpr auto baseClasses = std::make_tuple(
    );
};

////////////////////////////////////////////////////////////
// test_types::ChildClass
////////////////////////////////////////////////////////////

template <>
struct MetaStructInternal<test_types::ChildClass> {
    using Type = test_types::ChildClass;
    static constexpr std::string_view name{"ChildClass"};
    static constexpr auto publicFields = std::make_tuple(
        ClassMember<Type, int>{&Type::publicField, "publicField"}
    );
    static constexpr auto baseClasses = std::make_tuple(
        type_tag<test_types::BasicClass>{}
    );
};

////////////////////////////////////////////////////////////
// test_types::OtherBaseClass
////////////////////////////////////////////////////////////

template <>
struct MetaStructInternal<test_types::OtherBaseClass> {
    using Type = test_types::OtherBaseClass;
    static constexpr std::string_view name{"OtherBaseClass"};
    static constexpr auto publicFields = std::make_tuple(
        ClassMember<Type, char>{&Type::charField, "charField"}
    );
    static constexpr auto baseClasses = std::make_tuple(
    );
};

////////////////////////////////////////////////////////////
// test_types::SecondLevelChildClass
////////////////////////////////////////////////////////////

template <>
struct MetaStructInternal<test_types::SecondLevelChildClass> {
    using Type = test_types::SecondLevelChildClass;
    static constexpr std::string_view name{"SecondLevelChildClass"};
    static constexpr auto publicFields = std::make_tuple(
        ClassMember<Type, double>{&Type::someField, "someField"}
    );
    static constexpr auto baseClasses = std::make_tuple(
        type_tag<test_types::ChildClass>{},
        type_tag<test_types::OtherBaseClass>{}
    );
};

////////////////////////////////////////////////////////////
// test_types::ChildOfUnreflectedBaseClass
////////////////////////////////////////////////////////////

template <>
struct MetaStructInternal<test_types::ChildOfUnreflectedBaseClass> {
    using Type = test_types::ChildOfUnreflectedBaseClass;
    static constexpr std::string_view name{"ChildOfUnreflectedBaseClass"};
    static constexpr auto publicFields = std::make_tuple(
        ClassMember<Type, int>{&Type::childField, "childField"}
    );
    static constexpr auto baseClasses = std::make_tuple(
        // skipping unannotated base class test_types::UnreflectedBaseClass
    );
};

} // namespace reflecxx::detail
