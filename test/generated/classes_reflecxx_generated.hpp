#pragma once

// Autogenerated at 2021-12-09 00:26:14.573231 by visitor_generator.py.
// Do not edit, changes will be overwritten!

#include <type_traits>

#include <reflecxx/reflecxx_base.hpp>

namespace reflecxx {

////////////////////////////////////////////////////////////
// test_types::BasicClass
////////////////////////////////////////////////////////////

template <>
struct tuple_type<test_types::BasicClass> {
    using type = std::tuple<bool, int, double>;
};

template <typename Visitor, typename T,
          std::enable_if_t<std::is_same_v<test_types::BasicClass, std::remove_const_t<T>>, bool> = true>
constexpr void visit(T& toVisit, Visitor&& visitor) {
    visitor("b", toVisit.b);
    visitor("i", toVisit.i);
    visitor("d", toVisit.d);
}

namespace detail {
template <typename Visitor>
struct Acceptor<test_types::BasicClass, Visitor> {
    static constexpr void visitType(Visitor&& visitor) {
        visitor("b", type_tag<bool>{});
        visitor("i", type_tag<int>{});
        visitor("d", type_tag<double>{});
    }
};
} // namespace detail

////////////////////////////////////////////////////////////
// test_types::ChildClass
////////////////////////////////////////////////////////////

template <>
struct tuple_type<test_types::ChildClass> {
    using type = std::tuple<bool, int, double, int>;
};

template <typename Visitor, typename T,
          std::enable_if_t<std::is_same_v<test_types::ChildClass, std::remove_const_t<T>>, bool> = true>
constexpr void visit(T& toVisit, Visitor&& visitor) {
    visit(static_cast<test_types::BasicClass&>(toVisit), visitor);
    visitor("publicField", toVisit.publicField);
}

namespace detail {
template <typename Visitor>
struct Acceptor<test_types::ChildClass, Visitor> {
    static constexpr void visitType(Visitor&& visitor) {
        visit<test_types::BasicClass>(visitor);
        visitor("publicField", type_tag<int>{});
    }
};
} // namespace detail

////////////////////////////////////////////////////////////
// test_types::ChildOfUnreflectedBaseClass
////////////////////////////////////////////////////////////

template <>
struct tuple_type<test_types::ChildOfUnreflectedBaseClass> {
    using type = std::tuple<int>;
};

template <
    typename Visitor, typename T,
    std::enable_if_t<std::is_same_v<test_types::ChildOfUnreflectedBaseClass, std::remove_const_t<T>>, bool> = true>
constexpr void visit(T& toVisit, Visitor&& visitor) {
    // not visiting unannotated base class test_types::UnreflectedBaseClass
    visitor("childField", toVisit.childField);
}

namespace detail {
template <typename Visitor>
struct Acceptor<test_types::ChildOfUnreflectedBaseClass, Visitor> {
    static constexpr void visitType(Visitor&& visitor) {
        // not visiting unannotated base class test_types::UnreflectedBaseClass
        visitor("childField", type_tag<int>{});
    }
};
} // namespace detail

} // namespace reflecxx
