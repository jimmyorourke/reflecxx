#pragma once

#include "detail/reflecxx_detail.hpp"

namespace reflecxx {

template <typename T, typename V>
constexpr void visit(T&& instance, V&& visitor) {
    using namespace detail;
    // wrap visitor in something that binds member pointers
    tupleVisit(MetaStruct<remove_cvref_t<T>>::publicFields, MemberVisitor<T, V>{instance, visitor});
    tupleVisit(MetaStruct<remove_cvref_t<T>>::baseClasses, BaseClassMemberVisitor<T, V>{instance, visitor});
}

template <typename T, typename V>
constexpr void visit(V&& visitor) {
    using namespace detail;
    tupleVisit(MetaStruct<T>::publicFields, MemberTypeVisitor<V>{visitor});
    tupleVisit(MetaStruct<T>::baseClasses, BaseClassMemberTypeVisitor<V>{visitor});
}

// Aliases for the visit functions.
template <typename T, typename Visitor>
constexpr void forEachField(Visitor&& visitor) {
    visit<T>(std::forward<Visitor>(visitor));
}

template <typename T, typename Visitor>
constexpr void forEachField(T&& toVisit, Visitor&& visitor) {
    // The visit function overload will be autogenerated.
    visit(std::forward<T>(toVisit), std::forward<Visitor>(visitor));
}

// Type trait to identify Reflecxx visitable types (for which a visit function has been autogenerated).
template <typename T>
struct is_reflecxx_visitable;
template <typename T>
inline constexpr bool is_reflecxx_visitable_v = is_reflecxx_visitable<T>::value;

// Tag structs for passing types as objects.
// Type visitors are expected to take as parameters the name of the field and a specialized type_tag corresponding to
// the field's type. This allows the use of inheritance such that the base_tag can be used for general cases to avoid
// the compiler generating template instantiations for each field type when not necessary.
struct base_tag {};
template <typename T>
struct type_tag : base_tag {
    using type = T;
};
template <typename T>
using type_tag_t = typename type_tag<T>::type;

} // namespace reflecxx
