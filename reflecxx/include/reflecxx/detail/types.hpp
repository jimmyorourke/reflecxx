#pragma once

namespace reflecxx::detail {

// The following looks rather obtuse, but it's a neat trick that enables us to enforce that MetaStruct must be
// specialized via a static assertion, which can be more clear than just the obscure linker errors if there was only a
// base declaration without definition, while also enabling the definition of a type trait to check if a specific
// template specialization exists. Typically such a static_assert would end up getting triggered undesireably by the
// type trait. The caveat to how this is implemented is that the type that must be specialized is actually
// MetaStructInternal, while all uses (other than the type trait) should use MetaStruct. Additionally, specializations
// should not inherit from Unspecialized. This is a bit confusing and unfortunate, however all MetaStructInternal
// definitions should be autogenerated anyway, so we don't really have to think about it.
// Credits to Haven Szostak for helping me figure out this trick.

// Tag used for identification. We use inheritance as a simple way to tag types.
struct Unspecialized {};

template <typename T>
struct MetaStructInternal : Unspecialized {};

template <typename T>
struct MetaEnumInternal : Unspecialized {};

// Backport a useful trait from c++20
template <typename T>
struct remove_cvref {
    using type = std::remove_cv_t<std::remove_reference_t<T>>;
};
template <typename T>
using remove_cvref_t = typename remove_cvref<T>::type;

} // namespace reflecxx::detail
