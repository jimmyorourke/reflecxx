#pragma once

namespace reflecxx {

// The following looks rather obtuse, but it's a neat trick that enables us to enforce that MetaStruct must be
// specialized via a static assertion, which can be more clear than just the obscure linker errors if there was only a
// base declaration without definition, while also enabling the definition of a type trait to check if a specific
// template specialization exists. Typically such a static_assert would end up getting triggered undesireably by the
// type trait. The caveat to how this is implemented is that the type that must be specialized is actually
// MetaStructInternal, while all uses (other than the type trait) should use MetaStruct. Additionally, specializations
// should not inherit from Unspecialized. This is a bit confusing and unfortunate, however all MetaStructInternal
// definitions should be autogenerated anyway, so we don't really have to think about it.
// Credits to Haven Szostak for helping me figure out this trick.

namespace detail {

// Tag used for identification. We use inheritance as a simple way to tag types.
struct Unspecialized {};

template <typename T>
struct MetaStructInternal : Unspecialized {};

template <typename T>
struct MetaEnumInternal : Unspecialized {};

}
}
